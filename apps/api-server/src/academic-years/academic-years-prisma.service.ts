/**
 * ============================================================================
 * ACADEMIC YEARS PRISMA SERVICE
 * ============================================================================
 * 
 * Service Prisma pour la gestion des années académiques
 * avec génération automatique selon les règles nationales
 * 
 * ============================================================================
 */

import { Injectable, BadRequestException, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../database/prisma.service';
import { AcademicYearCalculatorService } from './academic-year-calculator.service';

@Injectable()
export class AcademicYearsPrismaService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly calculator: AcademicYearCalculatorService,
  ) {}

  /**
   * Génère automatiquement l'année scolaire courante pour un tenant
   * Utilise les règles nationales pour calculer les dates
   */
  async generateCurrentAcademicYear(tenantId: string): Promise<any> {
    // Calculer l'année scolaire courante
    const currentYear = this.calculator.getCurrentAcademicYear();
    const dates = this.calculator.calculateAcademicYearDates(currentYear);

    // Vérifier si l'année existe déjà
    const existing = await this.prisma.academicYear.findFirst({
      where: {
        tenantId,
        label: dates.label,
      },
    });

    if (existing) {
      // Si elle existe mais n'est pas active, l'activer
      if (!existing.isActive) {
        // Désactiver toutes les autres années actives
        await this.prisma.academicYear.updateMany({
          where: {
            tenantId,
            isActive: true,
          },
          data: {
            isActive: false,
          },
        });

        // Activer cette année
        return this.prisma.academicYear.update({
          where: { id: existing.id },
          data: {
            isActive: true,
            preEntryDate: dates.preEntryDate,
            startDate: dates.startDate,
            endDate: dates.endDate,
          },
        });
      }
      return existing;
    }

    // Désactiver toutes les autres années actives
    await this.prisma.academicYear.updateMany({
      where: {
        tenantId,
        isActive: true,
      },
      data: {
        isActive: false,
      },
    });

    // Créer la nouvelle année scolaire
    return this.prisma.academicYear.create({
      data: {
        tenantId,
        name: dates.name,
        label: dates.label,
        preEntryDate: dates.preEntryDate,
        startDate: dates.startDate,
        endDate: dates.endDate,
        isActive: true,
        isAutoGenerated: true,
      },
    });
  }

  /**
   * Génère l'année scolaire suivante pour un tenant
   */
  async generateNextAcademicYear(tenantId: string): Promise<any> {
    // Trouver l'année active actuelle
    const currentYear = await this.prisma.academicYear.findFirst({
      where: {
        tenantId,
        isActive: true,
      },
    });

    if (!currentYear) {
      throw new NotFoundException('No active academic year found');
    }

    // Extraire l'année de début du label (ex: "2024-2025" -> 2024)
    const startYear = parseInt(currentYear.label.split('-')[0]);
    const nextYear = startYear + 1;

    // Calculer les dates de l'année suivante
    const dates = this.calculator.calculateAcademicYearDates(nextYear);

    // Vérifier si l'année suivante existe déjà
    const existing = await this.prisma.academicYear.findFirst({
      where: {
        tenantId,
        label: dates.label,
      },
    });

    if (existing) {
      return existing;
    }

    // Créer l'année suivante (non active par défaut)
    return this.prisma.academicYear.create({
      data: {
        tenantId,
        name: dates.name,
        label: dates.label,
        preEntryDate: dates.preEntryDate,
        startDate: dates.startDate,
        endDate: dates.endDate,
        isActive: false,
        isAutoGenerated: true,
      },
    });
  }

  /**
   * Vérifie et génère automatiquement l'année suivante si l'année courante est terminée
   */
  async checkAndGenerateNextYear(tenantId: string): Promise<any | null> {
    const currentYear = await this.prisma.academicYear.findFirst({
      where: {
        tenantId,
        isActive: true,
      },
    });

    if (!currentYear) {
      // Pas d'année active, générer l'année courante
      return this.generateCurrentAcademicYear(tenantId);
    }

    // Vérifier si l'année est terminée
    if (this.calculator.isAcademicYearEnded(currentYear.endDate)) {
      // Désactiver l'année courante
      await this.prisma.academicYear.update({
        where: { id: currentYear.id },
        data: { isActive: false },
      });

      // Générer et activer l'année suivante
      const nextYear = await this.generateNextAcademicYear(tenantId);
      return this.prisma.academicYear.update({
        where: { id: nextYear.id },
        data: { isActive: true },
      });
    }

    return null; // Aucune action nécessaire
  }

  /**
   * Met à jour les dates d'une année scolaire (personnalisation)
   */
  async updateAcademicYearDates(
    id: string,
    tenantId: string,
    updates: {
      preEntryDate?: Date;
      startDate?: Date;
      endDate?: Date;
    },
  ): Promise<any> {
    const year = await this.prisma.academicYear.findFirst({
      where: { id, tenantId },
    });

    if (!year) {
      throw new NotFoundException(`Academic year with ID ${id} not found`);
    }

    // Vérifier que les dates sont cohérentes
    if (updates.preEntryDate && updates.startDate && updates.preEntryDate >= updates.startDate) {
      throw new BadRequestException('Pre-entry date must be before start date');
    }

    if (updates.startDate && updates.endDate && updates.startDate >= updates.endDate) {
      throw new BadRequestException('Start date must be before end date');
    }

    return this.prisma.academicYear.update({
      where: { id },
      data: {
        ...updates,
        isAutoGenerated: false, // Marquer comme modifiée manuellement
      },
    });
  }

  /**
   * Active une année scolaire (désactive les autres)
   */
  async activateAcademicYear(id: string, tenantId: string): Promise<any> {
    const year = await this.prisma.academicYear.findFirst({
      where: { id, tenantId },
    });

    if (!year) {
      throw new NotFoundException(`Academic year with ID ${id} not found`);
    }

    // Désactiver toutes les autres années
    await this.prisma.academicYear.updateMany({
      where: {
        tenantId,
        isActive: true,
        id: { not: id },
      },
      data: {
        isActive: false,
      },
    });

    // Activer cette année
    return this.prisma.academicYear.update({
      where: { id },
      data: { isActive: true },
    });
  }

  /**
   * Récupère l'année scolaire active pour un tenant
   */
  async getActiveAcademicYear(tenantId: string): Promise<any | null> {
    return this.prisma.academicYear.findFirst({
      where: {
        tenantId,
        isActive: true,
      },
    });
  }

  /**
   * Récupère toutes les années scolaires d'un tenant
   */
  async getAllAcademicYears(tenantId: string): Promise<any[]> {
    return this.prisma.academicYear.findMany({
      where: { tenantId },
      orderBy: { startDate: 'DESC' },
    });
  }
}

